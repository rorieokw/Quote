@page "/messages/{ConversationId:guid}"
@inject MessagesService MessagesService
@inject SignalRService SignalR
@inject AuthStateService AuthState
@inject NavigationManager Navigation
@implements IAsyncDisposable
@rendermode InteractiveAuto

<PageTitle>Conversation - Quote</PageTitle>

<div class="container py-4">
    @if (!AuthState.IsAuthenticated)
    {
        <div class="alert alert-warning">
            <h5 class="alert-heading">Sign in required</h5>
            <p class="mb-0">Please <a href="/login">sign in</a> to view messages.</p>
        </div>
    }
    else if (isLoading)
    {
        <div class="text-center py-5">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    }
    else if (conversation == null)
    {
        <div class="alert alert-danger">
            <h5 class="alert-heading">Conversation not found</h5>
            <p class="mb-0">This conversation may have been deleted or you don't have access to it.</p>
            <a href="/messages" class="btn btn-primary mt-3">Back to Messages</a>
        </div>
    }
    else
    {
        <div class="row">
            <div class="col-lg-8 mx-auto">
                <!-- Header -->
                <div class="card mb-3">
                    <div class="card-body d-flex align-items-center">
                        <a href="/messages" class="btn btn-outline-secondary me-3">
                            <i class="bi bi-arrow-left"></i>
                        </a>
                        <div class="avatar me-3">
                            @(conversation.OtherParty.Name?.Substring(0, 1).ToUpper() ?? "?")
                        </div>
                        <div class="flex-grow-1">
                            <h5 class="mb-0">@conversation.OtherParty.Name</h5>
                            <small class="text-muted">@conversation.OtherParty.UserType</small>
                            @if (otherUserTyping)
                            {
                                <small class="text-primary"><em>typing...</em></small>
                            }
                        </div>
                        <span class="badge @(isConnected ? "bg-success" : "bg-warning") me-2">
                            @(isConnected ? "Live" : "Connecting...")
                        </span>
                        <a href="/jobs/@conversation.JobId" class="btn btn-outline-primary btn-sm">
                            <i class="bi bi-file-text"></i> View Job
                        </a>
                    </div>
                    <div class="card-footer bg-light">
                        <small class="text-muted">
                            <strong>Job:</strong> @conversation.JobTitle
                            <span class="badge bg-secondary ms-2">@conversation.JobStatus</span>
                        </small>
                    </div>
                </div>

                <!-- Messages -->
                <div class="card chat-card">
                    <div class="card-body chat-messages" @ref="messagesContainer">
                        @foreach (var message in conversation.Messages)
                        {
                            @if (message.IsSystemMessage)
                            {
                                <div class="text-center my-3">
                                    <span class="badge bg-light text-muted">@message.Content</span>
                                </div>
                            }
                            else
                            {
                                <div class="message @(message.IsMine ? "mine" : "theirs")">
                                    <div class="message-bubble">
                                        <p class="mb-1">@message.Content</p>
                                        @if (!string.IsNullOrEmpty(message.MediaUrl))
                                        {
                                            @if (message.MediaType == "image")
                                            {
                                                <img src="@message.MediaUrl" alt="Attached image" class="img-fluid rounded mt-2" style="max-width: 300px;" />
                                            }
                                            else
                                            {
                                                <a href="@message.MediaUrl" target="_blank" class="d-block mt-2">
                                                    <i class="bi bi-file-earmark"></i> @(message.FileName ?? "Attachment")
                                                </a>
                                            }
                                        }
                                        <small class="text-muted d-block mt-1">@FormatTime(message.SentAt)</small>
                                    </div>
                                </div>
                            }
                        }
                    </div>

                    <!-- Input -->
                    <div class="card-footer">
                        <div class="input-group">
                            <input type="text"
                                   class="form-control"
                                   placeholder="Type a message..."
                                   value="@newMessage"
                                   @oninput="HandleInput"
                                   @onkeypress="HandleKeyPress"
                                   disabled="@isSending" />
                            <button class="btn btn-primary" @onclick="SendMessage" disabled="@(isSending || string.IsNullOrWhiteSpace(newMessage))">
                                @if (isSending)
                                {
                                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                }
                                else
                                {
                                    <i class="bi bi-send"></i>
                                }
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
</div>

<style>
    .avatar {
        width: 48px;
        height: 48px;
        background: #e7f1ff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        color: #0d6efd;
        flex-shrink: 0;
    }

    .chat-card {
        height: 60vh;
        display: flex;
        flex-direction: column;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 16px;
    }

    .message {
        display: flex;
    }

    .message.mine {
        justify-content: flex-end;
    }

    .message.theirs {
        justify-content: flex-start;
    }

    .message-bubble {
        max-width: 70%;
        padding: 12px 16px;
        border-radius: 16px;
    }

    .message.mine .message-bubble {
        background: #0d6efd;
        color: white;
        border-bottom-right-radius: 4px;
    }

    .message.mine .message-bubble .text-muted {
        color: rgba(255, 255, 255, 0.7) !important;
    }

    .message.theirs .message-bubble {
        background: #f8f9fa;
        color: #1f2937;
        border-bottom-left-radius: 4px;
    }

    .message-bubble p {
        word-wrap: break-word;
    }
</style>

@code {
    [Parameter]
    public Guid ConversationId { get; set; }

    private ElementReference messagesContainer;
    private ConversationDetailDto? conversation;
    private bool isLoading = true;
    private bool isSending = false;
    private bool isConnected = false;
    private bool otherUserTyping = false;
    private string newMessage = "";
    private System.Timers.Timer? typingTimer;

    protected override async Task OnInitializedAsync()
    {
        await AuthState.InitializeAsync();
        if (AuthState.IsAuthenticated)
        {
            await LoadConversation();
            await ConnectSignalR();
            await MarkAsRead();
        }
        else
        {
            isLoading = false;
        }
    }

    private async Task ConnectSignalR()
    {
        SignalR.OnConnectionStateChanged += HandleConnectionStateChanged;
        SignalR.OnMessageReceived += HandleMessageReceived;
        SignalR.OnMessagesRead += HandleMessagesRead;
        SignalR.OnUserTyping += HandleUserTyping;

        await SignalR.ConnectAsync();
        await SignalR.JoinConversationAsync(ConversationId);
    }

    private void HandleConnectionStateChanged(bool connected)
    {
        isConnected = connected;
        InvokeAsync(StateHasChanged);
    }

    private void HandleMessageReceived(MessageDto message)
    {
        if (conversation == null) return;

        InvokeAsync(async () =>
        {
            // Add message to the conversation
            conversation.Messages.Add(message);
            otherUserTyping = false;
            StateHasChanged();

            // Mark as read since we're viewing the conversation
            await MarkAsRead();
        });
    }

    private void HandleMessagesRead(Guid conversationId, Guid userId)
    {
        if (conversationId != ConversationId) return;

        InvokeAsync(() =>
        {
            // Update read receipts if needed
            StateHasChanged();
        });
    }

    private void HandleUserTyping(Guid conversationId, Guid userId, bool isTyping)
    {
        if (conversationId != ConversationId) return;
        if (conversation?.OtherParty?.UserId != userId) return;

        InvokeAsync(() =>
        {
            otherUserTyping = isTyping;
            StateHasChanged();
        });
    }

    private async Task LoadConversation()
    {
        isLoading = true;
        conversation = await MessagesService.GetConversationAsync(ConversationId);
        isLoading = false;
    }

    private async Task MarkAsRead()
    {
        await MessagesService.MarkAsReadAsync(ConversationId);
        if (isConnected)
        {
            await SignalR.MarkAsReadAsync(ConversationId);
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(newMessage) || isSending) return;

        isSending = true;
        var messageToSend = newMessage;
        newMessage = "";
        StateHasChanged();

        try
        {
            // Stop typing indicator
            await SignalR.StopTypingAsync(ConversationId);

            if (isConnected)
            {
                // Send via SignalR for real-time delivery
                await SignalR.SendMessageAsync(ConversationId, messageToSend);
            }
            else
            {
                // Fallback to HTTP if not connected
                var request = new SendMessageRequest(
                    ConversationId,
                    messageToSend,
                    null, null, null
                );
                var sent = await MessagesService.SendMessageAsync(request);
                if (sent != null && conversation != null)
                {
                    conversation.Messages.Add(sent);
                }
            }
        }
        catch
        {
            newMessage = messageToSend;
        }
        finally
        {
            isSending = false;
            StateHasChanged();
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(newMessage))
        {
            await SendMessage();
        }
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        newMessage = e.Value?.ToString() ?? "";

        // Send typing indicator
        if (isConnected && !string.IsNullOrWhiteSpace(newMessage))
        {
            await SignalR.StartTypingAsync(ConversationId);

            // Reset typing timer
            typingTimer?.Stop();
            typingTimer = new System.Timers.Timer(2000);
            typingTimer.Elapsed += async (s, ev) =>
            {
                typingTimer?.Stop();
                await SignalR.StopTypingAsync(ConversationId);
            };
            typingTimer.Start();
        }
    }

    private string FormatTime(DateTime dateTime)
    {
        var local = dateTime.ToLocalTime();
        var now = DateTime.Now;

        if (local.Date == now.Date)
            return local.ToString("h:mm tt");
        if (local.Date == now.Date.AddDays(-1))
            return "Yesterday " + local.ToString("h:mm tt");
        return local.ToString("MMM d, h:mm tt");
    }

    public async ValueTask DisposeAsync()
    {
        SignalR.OnConnectionStateChanged -= HandleConnectionStateChanged;
        SignalR.OnMessageReceived -= HandleMessageReceived;
        SignalR.OnMessagesRead -= HandleMessagesRead;
        SignalR.OnUserTyping -= HandleUserTyping;

        if (isConnected)
        {
            await SignalR.LeaveConversationAsync(ConversationId);
        }

        typingTimer?.Dispose();
    }
}
